import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import React, { memo, forwardRef, useMemo, Fragment, useState, useEffect, useRef, useCallback, useImperativeHandle } from 'react';
import styled, { css, keyframes, ThemeProvider } from 'styled-components';
import { areEqual, FixedSizeList } from 'react-window';

const _bounceKeyframes = /*#__PURE__*/keyframes(["0%,80%,100%{transform:scale(0);}40%{transform:scale(1.0);}"]);

const _fadeInKeyframes = /*#__PURE__*/keyframes(["from{opacity:0;}to{opacity:1;}"]);

const BOUNCE_ANIMATION_CSS = /*#__PURE__*/css(["", " 1.19s ease-in-out infinite"], _bounceKeyframes);
const FADE_IN_ANIMATION_CSS = /*#__PURE__*/css(["", " 0.225s ease-in-out forwards"], _fadeInKeyframes);
const SINGLE_VALUE_BASE_STYLE = /*#__PURE__*/css(["top:50%;overflow:hidden;position:absolute;white-space:nowrap;box-sizing:border-box;text-overflow:ellipsis;transform:translateY(-50%);"]);

const RfsTheme = {
  color: {
    border: '#ced4da',
    danger: '#dc3545',
    primary: '#007bff',
    disabled: '#e9ecef',
    placeholder: '#6E7276',
    dangerLight: 'rgba(220, 53, 69, 0.25)'
  },
  input: {},
  select: {},
  loader: {
    size: '0.625rem',
    padding: '0.375rem 0.75rem',
    animation: BOUNCE_ANIMATION_CSS,
    color: 'rgba(0, 123, 255, 0.42)'
  },
  icon: {
    color: '#ccc',
    hoverColor: '#A6A6A6',
    padding: '0 0.9375rem',
    clear: {
      width: '14px',
      height: '16px',
      animation: FADE_IN_ANIMATION_CSS,
      transition: 'color 0.15s ease-in-out'
    },
    caret: {
      size: '7px',
      transition: 'transform 0.25s ease-in-out, color 0.15s ease-in-out'
    }
  },
  control: {
    minHeight: '38px',
    borderWidth: '1px',
    borderStyle: 'solid',
    borderRadius: '0.25rem',
    boxShadow: '0 0 0 0.2rem',
    padding: '0.375rem 0.75rem',
    boxShadowColor: 'rgba(0, 123, 255, 0.25)',
    focusedBorderColor: 'rgba(0, 123, 255, 0.75)',
    transition: 'box-shadow 0.15s ease-in-out, border-color 0.15s ease-in-out'
  },
  menu: {
    padding: '0',
    width: '100%',
    margin: '0.5rem 0',
    borderRadius: '0.25rem',
    backgroundColor: '#fff',
    animation: FADE_IN_ANIMATION_CSS,
    boxShadow: '0 0 0 1px rgba(0, 0, 0, 0.1), 0 4px 11px rgba(0, 0, 0, 0.1)',
    option: {
      textAlign: 'left',
      selectedColor: '#fff',
      selectedBgColor: '#007bff',
      padding: '0.375rem 0.75rem',
      focusedBgColor: 'rgba(0, 123, 255, 0.20)'
    }
  },
  noOptions: {
    fontSize: '1.25rem',
    margin: '0.25rem 0',
    color: 'hsl(0, 0%, 60%)',
    padding: '0.375rem 0.75rem'
  },
  multiValue: {
    margin: '1px 2px',
    borderRadius: '0.25rem',
    backgroundColor: '#e7edf3',
    animation: FADE_IN_ANIMATION_CSS,
    label: {
      fontSize: '0.825em',
      borderRadius: '0.25rem',
      padding: '1px 2px 1px 6px'
    },
    clear: {
      fontWeight: 700,
      padding: '0 7px',
      fontSize: '0.67em',
      alignItems: 'center',
      borderRadius: '0.25rem',
      transition: 'color 0.15s ease-in-out, background-color 0.15s ease-in-out'
    }
  }
};

const MENU_ITEM_SIZE_DEFAULT = 35;
const MENU_MAX_HEIGHT_DEFAULT = 300;
const LOADING_MSG_DEFAULT = 'Loading...';
const NO_OPTIONS_MSG_DEFAULT = 'No options';
const PLACEHOLDER_DEFAULT = 'Select option...';
const FOCUSED_OPTION_DEFAULT = {
  index: -1
};
const NULL = null;
const EMPTY_ARRAY = [];
const INPUT_MIN_WIDTH_PX = 2;

const DIACRITICS_REGEXP = /[\u0300-\u036f]/g;
const IE_EDGE_BROWSER_REGEXP = /(MSIE|Trident\/|Edge\/|Edg\/)/i;

const _isTest = process.env.NODE_ENV === 'test';

const OPTION_CLS = 'rfs-option';
const OPTION_FOCUSED_CLS = `${OPTION_CLS}-focused`;
const OPTION_SELECTED_CLS = `${OPTION_CLS}-selected`;
const OPTION_DISABLED_CLS = `${OPTION_CLS}-disabled`;
const CARET_ICON_CLS = 'rfs-caret-icon';
const CLEAR_ICON_CLS = 'rfs-clear-icon';
const LOADING_DOTS_CLS = 'rfs-loading-dots';
const AUTOSIZE_INPUT_CLS = 'rfs-autosize-input';
const MENU_CONTAINER_CLS = 'rfs-menu-container';
const SELECT_CONTAINER_CLS = 'rfs-select-container';
const CONTROL_CONTAINER_CLS = 'rfs-control-container';
const ARIA_LIVE_TESTID = _isTest ? 'rfs-aria-live' : undefined;
const CLEAR_ICON_TESTID = _isTest ? CLEAR_ICON_CLS : undefined;
const CARET_ICON_TESTID = _isTest ? CARET_ICON_CLS : undefined;
const AUTOSIZE_INPUT_TESTID = _isTest ? AUTOSIZE_INPUT_CLS : undefined;
const MENU_CONTAINER_TESTID = _isTest ? MENU_CONTAINER_CLS : undefined;
const CLEAR_ICON_MV_TESTID = _isTest ? `${CLEAR_ICON_CLS}-mv` : undefined;
const SELECT_CONTAINER_TESTID = _isTest ? SELECT_CONTAINER_CLS : undefined;
const CONTROL_CONTAINER_TESTID = _isTest ? CONTROL_CONTAINER_CLS : undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function stripDiacritics(value) {
  return value.normalize('NFD').replace(DIACRITICS_REGEXP, '');
}

function isArrayWithLength(test) {
  return Array.isArray(test) && !!test.length;
}
function isPlainObject(test) {
  return test !== null && typeof test === 'object' && !Array.isArray(test);
}
function trimAndFormatFilterStr(value, filterIgnoreCase, filterIgnoreAccents) {
  let trimVal = value.trim();

  if (filterIgnoreCase) {
    trimVal = trimVal.toLowerCase();
  }

  return !filterIgnoreAccents ? trimVal : stripDiacritics(trimVal);
}
function buildOptionClassName(isDisabled, isSelected, isFocused) {
  let className = OPTION_CLS;
  if (isDisabled) className += ' ' + OPTION_DISABLED_CLS;
  if (isSelected) className += ' ' + OPTION_SELECTED_CLS;
  if (isFocused) className += ' ' + OPTION_FOCUSED_CLS;
  return className;
}
function normalizeValue(value, getOptionValue, getOptionLabel) {
  const initialValues = Array.isArray(value) ? value : isPlainObject(value) ? [value] : EMPTY_ARRAY;
  return isArrayWithLength(initialValues) ? initialValues.map(x => ({
    data: x,
    value: getOptionValue(x),
    label: getOptionLabel(x)
  })) : initialValues;
}
const mergeDeep = (target, source) => {
  const output = _objectSpread({}, target);

  Object.keys(source).forEach(key => {
    const sourceProp = source[key];
    output[key] = isPlainObject(sourceProp) && key !== 'animation' ? key in target ? mergeDeep(target[key], sourceProp) : sourceProp : sourceProp || '';
  });
  return output;
};

function getScrollTop(el) {
  return isDocumentElement(el) ? window.pageYOffset : el.scrollTop;
}

function scrollTo(el, top) {
  isDocumentElement(el) ? window.scrollTo(0, top) : el.scrollTop = top;
}

function isDocumentElement(el) {
  return el === document.documentElement || el === document.body || el === window;
}

function styleHasOverlfow(style) {
  const {
    overflow,
    overflowX,
    overflowY
  } = style;

  const isOverflow = x => x === 'auto' || x === 'scroll';

  return isOverflow(overflow) || isOverflow(overflowX) || isOverflow(overflowY);
}

function getScrollParent(el) {
  let style = getComputedStyle(el);
  const excludeStaticParent = style.position === 'absolute';

  if (style.position === 'fixed') {
    return document.documentElement;
  }

  for (let parent = el; parent = parent ? parent.parentElement : null;) {
    style = getComputedStyle(parent);

    if (!(excludeStaticParent && style.position === 'static') && styleHasOverlfow(style)) {
      return parent;
    }
  }

  return document.documentElement;
}

const smoothScrollTo = (el, to, duration = 300, callback) => {
  let currentTime = 0;
  const start = getScrollTop(el);
  const change = to - start;

  const easeOutCubic = t => change * ((t = t / duration - 1) * t * t + 1) + start;

  const smoothScroller = () => {
    currentTime += 5;
    scrollTo(el, easeOutCubic(currentTime));
    currentTime < duration ? window.requestAnimationFrame(smoothScroller) : callback === null || callback === void 0 ? void 0 : callback();
  };

  window.requestAnimationFrame(smoothScroller);
};

const calculateMenuTop = (menuHeight, menuEl, controlEl) => {
  const menuHeightOrDefault = menuHeight > 0 || !menuEl ? menuHeight : menuEl.getBoundingClientRect().height;
  const controlHeight = controlEl ? controlEl.getBoundingClientRect().height : 0;
  const menuElStyle = menuEl && getComputedStyle(menuEl);
  const marginBottom = menuElStyle ? parseInt(menuElStyle.marginBottom, 10) : 0;
  const marginTop = menuElStyle ? parseInt(menuElStyle.marginTop, 10) : 0;
  const basePx = -Math.abs(menuHeightOrDefault + controlHeight);
  const adjustPx = marginBottom + marginTop;
  return 'calc(' + basePx + 'px' + adjustPx + 'px)';
};
const menuFitsBelowControl = el => {
  if (!el) return true;
  const scrollParent = getScrollParent(el);
  const {
    top,
    height
  } = el.getBoundingClientRect();
  const scrollSpaceBelow = scrollParent.getBoundingClientRect().height - getScrollTop(scrollParent) - top;
  return scrollSpaceBelow >= height;
};
const scrollMenuIntoViewOnOpen = (menuEl, menuScrollDuration, scrollMenuIntoView, handleOnMenuOpen) => {
  if (!menuEl) {
    handleOnMenuOpen();
    return;
  }

  const {
    top,
    height,
    bottom
  } = menuEl.getBoundingClientRect();
  const viewInner = window.innerHeight;
  const viewSpaceBelow = viewInner - top;

  if (viewSpaceBelow >= height) {
    handleOnMenuOpen();
    return;
  }

  const scrollParent = getScrollParent(menuEl);
  const scrollTop = getScrollTop(scrollParent);
  const scrollSpaceBelow = scrollParent.getBoundingClientRect().height - scrollTop - top;
  const notEnoughSpaceBelow = scrollSpaceBelow < height;

  if (notEnoughSpaceBelow || !scrollMenuIntoView) {
    const condensedMenuHeight = notEnoughSpaceBelow ? scrollSpaceBelow : undefined;
    handleOnMenuOpen(condensedMenuHeight);
    return;
  }

  const marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  const scrollDown = bottom - viewInner + scrollTop + marginBottom;
  smoothScrollTo(scrollParent, scrollDown, menuScrollDuration, handleOnMenuOpen);
};

const isMicrosoftBrowser = () => {
  return typeof navigator !== 'undefined' && IE_EDGE_BROWSER_REGEXP.test(navigator.userAgent);
};
const isTouchDevice = () => {
  return typeof window !== 'undefined' && 'ontouchstart' in window || typeof navigator !== 'undefined' && !!navigator.maxTouchPoints;
};

const Option = /*#__PURE__*/memo(({
  index,
  style,
  data: {
    menuOptions,
    selectOption,
    renderOptionLabel,
    focusedOptionIndex
  }
}) => {
  const {
    data,
    value,
    label,
    isDisabled,
    isSelected
  } = menuOptions[index];
  const className = buildOptionClassName(isDisabled, isSelected, index === focusedOptionIndex);
  const onClick = !isDisabled ? () => selectOption({
    data,
    value,
    label
  }, isSelected) : undefined;
  return /*#__PURE__*/React.createElement("div", {
    style: style,
    onClick: onClick,
    className: className
  }, renderOptionLabel(data));
}, areEqual);
Option.displayName = 'Option';

const NoOptionsMsg = /*#__PURE__*/styled.div.withConfig({
  displayName: "NoOptionsMsg",
  componentId: "sc-1iuktah-0"
})(["text-align:center;color:", ";margin:", ";padding:", ";font-size:", ";", ""], ({
  theme
}) => theme.noOptions.color, ({
  theme
}) => theme.noOptions.margin, ({
  theme
}) => theme.noOptions.padding, ({
  theme
}) => theme.noOptions.fontSize, ({
  theme
}) => theme.noOptions.css);
const Menu = /*#__PURE__*/forwardRef(({
  width,
  height,
  itemSize,
  isLoading,
  loadingMsg,
  menuOptions,
  selectOption,
  noOptionsMsg,
  overscanCount,
  itemKeySelector,
  renderOptionLabel,
  focusedOptionIndex
}, ref) => {
  const itemKey = useMemo(() => {
    return itemKeySelector ? (idx, data) => data.menuOptions[idx][itemKeySelector] : undefined;
  }, [itemKeySelector]);
  const itemData = useMemo(() => ({
    menuOptions,
    selectOption,
    renderOptionLabel,
    focusedOptionIndex
  }), [menuOptions, focusedOptionIndex, selectOption, renderOptionLabel]);

  if (isLoading) {
    return /*#__PURE__*/React.createElement(NoOptionsMsg, null, loadingMsg);
  }

  return /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(FixedSizeList, {
    ref: ref,
    width: width,
    height: height,
    itemKey: itemKey,
    itemSize: itemSize,
    itemData: itemData,
    overscanCount: overscanCount,
    itemCount: menuOptions.length
  }, Option), !isArrayWithLength(menuOptions) && /*#__PURE__*/React.createElement(NoOptionsMsg, null, noOptionsMsg));
});
Menu.displayName = 'Menu';

const MultiValueWrapper = /*#__PURE__*/styled.div.withConfig({
  displayName: "MultiValueWrapper",
  componentId: "sc-5mvzot-0"
})(["min-width:0;display:flex;", " ", ""], ({
  theme: {
    multiValue
  }
}) => css(["margin:", ";animation:", ";border-radius:", ";background-color:", ";"], multiValue.margin, multiValue.animation, multiValue.borderRadius, multiValue.backgroundColor), ({
  theme
}) => theme.multiValue.css);
const Label = /*#__PURE__*/styled.div.withConfig({
  displayName: "Label",
  componentId: "sc-5mvzot-1"
})(["overflow:hidden;white-space:nowrap;text-overflow:ellipsis;padding:", ";font-size:", ";border-radius:", ";"], ({
  theme
}) => theme.multiValue.label.padding, ({
  theme
}) => theme.multiValue.label.fontSize, ({
  theme
}) => theme.multiValue.label.borderRadius);
const Clear = /*#__PURE__*/styled.div.withConfig({
  displayName: "Clear",
  componentId: "sc-5mvzot-2"
})(["display:flex;", ""], ({
  isFocused,
  theme: {
    color,
    multiValue: {
      clear
    }
  }
}) => css(["padding:", ";font-size:", ";transition:", ";align-items:", ";font-weight:", ";border-radius:", ";background-color:", ";:hover{color:", ";background-color:", ";}"], clear.padding, clear.fontSize, clear.transition, clear.alignItems, clear.fontWeight, clear.borderRadius, isFocused ? color.dangerLight : 'transparent', color.danger, color.dangerLight));

const MultiValue = ({
  data,
  value,
  isFocused,
  renderOptionLabel,
  removeSelectedOption
}) => /*#__PURE__*/React.createElement(MultiValueWrapper, null, /*#__PURE__*/React.createElement(Label, null, renderOptionLabel(data)), /*#__PURE__*/React.createElement(Clear, {
  isFocused: isFocused,
  "data-testid": CLEAR_ICON_MV_TESTID,
  onTouchEnd: e => removeSelectedOption(value, e),
  onMouseDown: e => removeSelectedOption(value, e)
}, "X"));

const SingleValue = /*#__PURE__*/styled.div.withConfig({
  displayName: "SingleValue",
  componentId: "sc-1137-0"
})(["", " max-width:calc(100% - 0.5rem);"], SINGLE_VALUE_BASE_STYLE);
const Placeholder = /*#__PURE__*/styled.div.withConfig({
  displayName: "Placeholder",
  componentId: "sc-1137-1"
})(["", " color:", ";"], SINGLE_VALUE_BASE_STYLE, ({
  theme
}) => theme.color.placeholder);
const Value = /*#__PURE__*/memo(({
  isMulti,
  inputValue,
  placeholder,
  selectedOption,
  focusedMultiValue,
  renderOptionLabel,
  renderMultiOptions,
  removeSelectedOption
}) => {
  if (inputValue && (!isMulti || isMulti && (!isArrayWithLength(selectedOption) || renderMultiOptions))) {
    return null;
  }

  if (!isArrayWithLength(selectedOption)) {
    return /*#__PURE__*/React.createElement(Placeholder, null, placeholder);
  }

  if (!isMulti) {
    return /*#__PURE__*/React.createElement(SingleValue, null, renderOptionLabel(selectedOption[0].data));
  }

  return /*#__PURE__*/React.createElement(Fragment, null, renderMultiOptions ? renderMultiOptions({
    selected: selectedOption,
    renderOptionLabel
  }) : selectedOption.map(({
    data,
    value
  }) => /*#__PURE__*/React.createElement(MultiValue, {
    key: value,
    data: data,
    value: value,
    renderOptionLabel: renderOptionLabel,
    isFocused: value === focusedMultiValue,
    removeSelectedOption: removeSelectedOption
  })));
});
Value.displayName = 'Value';

const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    if (delay === undefined) return;
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return delay === undefined ? value : debouncedValue;
};

var MenuPositionEnum;

(function (MenuPositionEnum) {
  MenuPositionEnum["TOP"] = "top";
  MenuPositionEnum["AUTO"] = "auto";
  MenuPositionEnum["BOTTOM"] = "bottom";
})(MenuPositionEnum || (MenuPositionEnum = {}));

var FilterMatchEnum;

(function (FilterMatchEnum) {
  FilterMatchEnum["ANY"] = "any";
  FilterMatchEnum["START"] = "start";
})(FilterMatchEnum || (FilterMatchEnum = {}));

var ValueIndexEnum;

(function (ValueIndexEnum) {
  ValueIndexEnum["NEXT"] = "next";
  ValueIndexEnum["PREVIOUS"] = "prev";
})(ValueIndexEnum || (ValueIndexEnum = {}));

var OptionIndexEnum;

(function (OptionIndexEnum) {
  OptionIndexEnum["UP"] = "up";
  OptionIndexEnum["DOWN"] = "down";
  OptionIndexEnum["LAST"] = "last";
  OptionIndexEnum["FIRST"] = "first";
})(OptionIndexEnum || (OptionIndexEnum = {}));

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const useMenuOptions = (options, debouncedInputValue, filterMatchFrom, selectedOption, getOptionValue, getOptionLabel, getIsOptionDisabled, getFilterOptionString, filterIgnoreCase, filterIgnoreAccents, isMulti, hideSelectedOptions, async) => {
  const [menuOptions, setMenuOptions] = useState(EMPTY_ARRAY);
  const searchValue = !async ? debouncedInputValue : '';
  const hideSelectedOptionsOrDefault = typeof hideSelectedOptions !== 'boolean' ? !!isMulti : hideSelectedOptions;
  useEffect(() => {
    const normalizedInput = trimAndFormatFilterStr(searchValue, filterIgnoreCase, filterIgnoreAccents);
    const selectedHash = !!selectedOption.length ? new Set(selectedOption.map(x => x.value)) : undefined;

    const getIsOptionDisabledOrDefault = getIsOptionDisabled || (data => !!data.isDisabled);

    const getFilterOptionStringOrDefault = getFilterOptionString || (option => typeof option.label === 'string' ? option.label : `${option.label}`);

    const isOptionFilterMatch = menuOption => {
      const optionStr = getFilterOptionStringOrDefault(menuOption);
      const normalizedOptionLabel = trimAndFormatFilterStr(optionStr, filterIgnoreCase, filterIgnoreAccents);
      return filterMatchFrom === FilterMatchEnum.ANY ? normalizedOptionLabel.indexOf(normalizedInput) > -1 : normalizedOptionLabel.substr(0, normalizedInput.length) === normalizedInput;
    };

    const parseMenuOption = data => {
      const value = getOptionValue(data);
      const label = getOptionLabel(data);

      const menuOption = _objectSpread$1(_objectSpread$1({
        data,
        value,
        label
      }, getIsOptionDisabledOrDefault(data) && {
        isDisabled: true
      }), (selectedHash === null || selectedHash === void 0 ? void 0 : selectedHash.has(value)) && {
        isSelected: true
      });

      if (normalizedInput && !isOptionFilterMatch(menuOption) || hideSelectedOptionsOrDefault && menuOption.isSelected) {
        return;
      }

      return menuOption;
    };

    const nextMenuOptions = [];

    for (let i = 0; i < options.length; i++) {
      const option = parseMenuOption(options[i]);
      option && nextMenuOptions.push(option);
    }

    setMenuOptions(nextMenuOptions);
  }, [options, selectedOption, searchValue, hideSelectedOptionsOrDefault, filterMatchFrom, filterIgnoreCase, filterIgnoreAccents, getFilterOptionString, getIsOptionDisabled, getOptionValue, getOptionLabel]);
  return menuOptions;
};

const useUpdateEffect = (effect, deps) => {
  const isFirstRender = useRef(true);
  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      return effect();
    }
  }, deps);
};

const useMenuPositioner = (menuRef, controlRef, menuOpen, menuPosition, menuItemSize, menuHeightDefault, menuOptionsLength, menuScrollDuration, scrollMenuIntoView, onMenuOpen, onMenuClose) => {
  const resetMenuHeightRef = useRef(false);
  const isMenuTopPositionRef = useRef(false);
  const [menuHeight, setMenuHeight] = useState(menuHeightDefault);
  const [isMenuTopPosition, setIsMenuTopPosition] = useState(menuPosition === MenuPositionEnum.TOP);
  useEffect(() => {
    isMenuTopPositionRef.current = isMenuTopPosition;
  }, [isMenuTopPosition]);
  useEffect(() => {
    const isTopPosition = menuPosition === MenuPositionEnum.TOP || menuPosition === MenuPositionEnum.AUTO && !menuFitsBelowControl(menuRef.current);
    setIsMenuTopPosition(isTopPosition);
  }, [menuRef, menuPosition]);
  useUpdateEffect(() => {
    if (menuOpen) {
      const handleOnMenuOpen = availableSpace => {
        onMenuOpen === null || onMenuOpen === void 0 ? void 0 : onMenuOpen();

        if (availableSpace) {
          resetMenuHeightRef.current = true;
          setMenuHeight(availableSpace);
        }
      };

      !isMenuTopPositionRef.current ? scrollMenuIntoViewOnOpen(menuRef.current, menuScrollDuration, scrollMenuIntoView, handleOnMenuOpen) : handleOnMenuOpen();
    } else {
      onMenuClose === null || onMenuClose === void 0 ? void 0 : onMenuClose();

      if (resetMenuHeightRef.current) {
        resetMenuHeightRef.current = false;
        setMenuHeight(menuHeightDefault);
      }
    }
  }, [menuRef, menuOpen, onMenuClose, onMenuOpen, menuHeightDefault, scrollMenuIntoView, menuScrollDuration]);
  const menuHeightCalc = Math.min(menuHeight, menuOptionsLength * menuItemSize);
  const menuStyleTop = isMenuTopPosition ? calculateMenuTop(menuHeightCalc, menuRef.current, controlRef.current) : undefined;
  return [menuStyleTop, menuHeightCalc];
};

const SizerDiv = /*#__PURE__*/styled.div.withConfig({
  displayName: "SizerDiv",
  componentId: "sc-1ivcalt-0"
})(["top:0;left:0;height:0;overflow:scroll;white-space:pre;position:absolute;visibility:hidden;font-size:inherit;font-weight:inherit;font-family:inherit;", ""], ({
  theme
}) => theme.input.css);
const Input = /*#__PURE__*/styled.input.withConfig({
  displayName: "Input",
  componentId: "sc-1ivcalt-1"
})(["border:0;outline:0;padding:0;cursor:text;background:0;color:inherit;font-size:inherit;font-weight:inherit;font-family:inherit;box-sizing:content-box;:read-only{opacity:0;cursor:default;}:required{", "}", " ", ""], ({
  theme,
  isInvalid
}) => isInvalid && theme.input.cssRequired, ({
  theme
}) => theme.input.css, isMicrosoftBrowser() && '::-ms-clear{display:none;}');
const AutosizeInput = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  id,
  onBlur,
  onFocus,
  readOnly,
  required,
  onChange,
  ariaLabel,
  inputValue,
  addClassNames,
  ariaLabelledBy,
  selectedOption
}, ref) => {
  const sizerRef = useRef(null);
  const [inputWidth, setInputWidth] = useState(INPUT_MIN_WIDTH_PX);
  const isInvalid = required && !isArrayWithLength(selectedOption);
  const autosizeInputAttrs = {
    isInvalid,
    tabIndex: 0,
    type: 'text',
    spellCheck: false,
    autoCorrect: 'off',
    autoComplete: 'off',
    autoCapitalize: 'none',
    'aria-label': ariaLabel,
    'aria-autocomplete': 'list',
    'aria-labelledby': ariaLabelledBy,
    'data-testid': AUTOSIZE_INPUT_TESTID,
    style: {
      width: inputWidth
    }
  };
  useUpdateEffect(() => {
    if (sizerRef.current) {
      setInputWidth(sizerRef.current.scrollWidth + INPUT_MIN_WIDTH_PX);
    }
  }, [inputValue]);
  return /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(Input, Object.assign({
    id: id,
    ref: ref,
    onBlur: onBlur,
    onFocus: onFocus,
    value: inputValue,
    readOnly: readOnly,
    required: isInvalid
  }, autosizeInputAttrs, {
    onChange: !readOnly ? onChange : undefined,
    className: addClassNames ? AUTOSIZE_INPUT_CLS : undefined
  })), /*#__PURE__*/React.createElement(SizerDiv, {
    ref: sizerRef
  }, inputValue));
}));
AutosizeInput.displayName = 'AutosizeInput';

const StyledLoadingDots = /*#__PURE__*/styled.div.withConfig({
  displayName: "StyledLoadingDots",
  componentId: "d2zqaw-0"
})(["display:flex;align-self:center;text-align:center;margin-right:0.25rem;padding:", ";> div{border-radius:100%;display:inline-block;", ":nth-of-type(1){animation-delay:-0.272s;}:nth-of-type(2){animation-delay:-0.136s;}}"], ({
  theme
}) => theme.loader.padding, ({
  theme: {
    loader
  }
}) => css(["width:", ";height:", ";background-color:", ";animation:", ";"], loader.size, loader.size, loader.color, loader.animation));

const LoadingDots = ({
  addClassNames
}) => /*#__PURE__*/React.createElement(StyledLoadingDots, {
  "aria-hidden": 'true',
  className: addClassNames ? LOADING_DOTS_CLS : undefined
}, /*#__PURE__*/React.createElement("div", null), /*#__PURE__*/React.createElement("div", null), /*#__PURE__*/React.createElement("div", null));

const IndicatorIconsWrapper = /*#__PURE__*/styled.div.withConfig({
  displayName: "IndicatorIconsWrapper",
  componentId: "sc-1r9uxct-0"
})(["display:flex;flex-shrink:0;align-items:center;align-self:stretch;box-sizing:border-box;"]);
const IndicatorIcon = /*#__PURE__*/styled.div.withConfig({
  displayName: "IndicatorIcon",
  componentId: "sc-1r9uxct-1"
})(["height:100%;display:flex;align-items:center;box-sizing:border-box;color:", ";padding:", ";:hover{color:", ";}", ""], ({
  theme
}) => theme.icon.color, ({
  theme
}) => theme.icon.padding, ({
  theme
}) => theme.icon.hoverColor, ({
  theme
}) => theme.icon.css);
const ClearSvg = /*#__PURE__*/styled.svg.withConfig({
  displayName: "ClearSvg",
  componentId: "sc-1r9uxct-2"
})(["fill:currentColor;", ""], ({
  theme: {
    icon: {
      clear
    }
  }
}) => css(["width:", ";height:", ";animation:", ";transition:", ";"], clear.width, clear.height, clear.animation, clear.transition));
const Caret = /*#__PURE__*/styled.div.withConfig({
  displayName: "Caret",
  componentId: "sc-1r9uxct-3"
})(["transition:", ";border-top:", " dashed;border-left:", " solid transparent;border-right:", " solid transparent;", ""], ({
  theme
}) => theme.icon.caret.transition, ({
  theme
}) => theme.icon.caret.size, ({
  theme
}) => theme.icon.caret.size, ({
  theme
}) => theme.icon.caret.size, ({
  menuOpen,
  isInvalid,
  theme: {
    color
  }
}) => menuOpen && css(["transform:rotate(180deg);color:", ";"], isInvalid ? color.danger : color.caretActive || color.primary));
const Separator = /*#__PURE__*/styled.div.withConfig({
  displayName: "Separator",
  componentId: "sc-1r9uxct-4"
})(["width:1px;margin:0.5rem 0;align-self:stretch;box-sizing:border-box;background-color:", ";"], ({
  theme
}) => theme.color.iconSeparator || theme.color.border);

const ClearIcon = ({
  addClassNames
}) => /*#__PURE__*/React.createElement(ClearSvg, {
  "aria-hidden": 'true',
  viewBox: '0 0 14 16',
  className: addClassNames ? CLEAR_ICON_CLS : undefined
}, /*#__PURE__*/React.createElement("path", {
  fillRule: 'evenodd',
  d: 'M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z'
}));

const IndicatorIcons = /*#__PURE__*/memo(({
  menuOpen,
  clearIcon,
  caretIcon,
  isInvalid,
  showClear,
  isLoading,
  isDisabled,
  loadingNode,
  addClassNames,
  onCaretMouseDown,
  onClearMouseDown
}) => {
  const forwardState = typeof caretIcon === 'function' || typeof clearIcon === 'function' ? {
    menuOpen,
    isLoading: !!isLoading,
    isInvalid: !!isInvalid,
    isDisabled: !!isDisabled
  } : undefined;

  const renderIconFn = renderer => {
    return typeof renderer === 'function' ? renderer(forwardState) : renderer;
  };

  return /*#__PURE__*/React.createElement(IndicatorIconsWrapper, null, showClear && !isLoading && /*#__PURE__*/React.createElement(IndicatorIcon, {
    onTouchEnd: onClearMouseDown,
    onMouseDown: onClearMouseDown,
    "data-testid": CLEAR_ICON_TESTID
  }, renderIconFn(clearIcon) || /*#__PURE__*/React.createElement(ClearIcon, {
    addClassNames: addClassNames
  })), isLoading && (loadingNode || /*#__PURE__*/React.createElement(LoadingDots, {
    addClassNames: addClassNames
  })), /*#__PURE__*/React.createElement(Separator, null), /*#__PURE__*/React.createElement(IndicatorIcon, {
    onTouchEnd: onCaretMouseDown,
    onMouseDown: onCaretMouseDown,
    "data-testid": CARET_ICON_TESTID
  }, renderIconFn(caretIcon) || /*#__PURE__*/React.createElement(Caret, {
    "aria-hidden": 'true',
    menuOpen: menuOpen,
    isInvalid: isInvalid,
    className: addClassNames ? CARET_ICON_CLS : undefined
  })));
});
IndicatorIcons.displayName = 'IndicatorIcons';

const A11yText = /*#__PURE__*/styled.span.withConfig({
  displayName: "A11yText",
  componentId: "sc-4snj8z-0"
})(["border:0;padding:0;width:1px;height:1px;margin:-1px;overflow:hidden;position:absolute;white-space:nowrap;clip:rect(0 0 0 0);clip-path:inset(50%);"]);

const AriaLiveRegion = ({
  menuOpen,
  isFocused,
  ariaLabel,
  inputValue,
  optionCount,
  isSearchable,
  focusedOption,
  selectedOption
}) => {
  if (!isFocused) {
    return null;
  }

  const optionsMsg = `${optionCount} result(s) available${inputValue ? ' for search input ' + inputValue : ''}.`;
  const focusedMsg = focusedOption.value ? `Focused option: ${focusedOption.label}${focusedOption.isDisabled ? ' - disabled' : ''}, ${focusedOption.index + 1} of ${optionCount}.` : '';
  const menuMsg = menuOpen ? 'Use Up and Down arrow keys to choose options, press Enter or Tab to select the currently focused option, press Escape to close the menu.' : `${ariaLabel || 'Select'} is focused${isSearchable ? ', type to filter options' : ''}, press Down arrow key to open the menu.`;
  const selectedOptionLabel = isArrayWithLength(selectedOption) ? selectedOption.map(({
    label
  }) => label).join(' ') : 'N/A';
  const selectedOptionMsg = `Selected option: ${selectedOptionLabel}`;
  const extendedFeedbackMsg = `${focusedMsg} ${optionsMsg} ${menuMsg}`;
  return /*#__PURE__*/React.createElement(A11yText, {
    "aria-live": 'polite',
    "data-testid": ARIA_LIVE_TESTID
  }, /*#__PURE__*/React.createElement("span", null, "\u00A0", selectedOptionMsg), /*#__PURE__*/React.createElement("span", null, "\u00A0", extendedFeedbackMsg));
};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const SelectWrapper = /*#__PURE__*/styled.div.withConfig({
  displayName: "SelectWrapper",
  componentId: "kcrmu9-0"
})(["position:relative;box-sizing:border-box;", ""], ({
  theme
}) => theme.select.css);
const ValueWrapper = /*#__PURE__*/styled.div.withConfig({
  displayName: "ValueWrapper",
  componentId: "kcrmu9-1"
})(["flex:1 1 0%;display:flex;flex-wrap:wrap;overflow:hidden;position:relative;align-items:center;box-sizing:border-box;padding:", ";"], ({
  theme
}) => theme.control.padding);
const ControlWrapper = /*#__PURE__*/styled.div.withConfig({
  displayName: "ControlWrapper",
  componentId: "kcrmu9-2"
})(["outline:0;display:flex;flex-wrap:wrap;cursor:default;position:relative;align-items:center;box-sizing:border-box;justify-content:space-between;", " ", " ", ""], ({
  isDisabled,
  isFocused,
  isInvalid,
  theme: {
    control,
    color
  }
}) => css(["transition:", ";border-style:", ";border-width:", ";border-radius:", ";min-height:", ";border-color:", ";", " ", " ", " ", ""], control.transition, control.borderStyle, control.borderWidth, control.borderRadius, control.height || control.minHeight, isInvalid ? color.danger : isFocused ? control.focusedBorderColor : color.border, isDisabled ? 'pointer-events: none;' : '', control.height ? `height: ${control.height};` : '', control.backgroundColor || isDisabled ? `background-color: ${isDisabled ? color.disabled : control.backgroundColor};` : '', isFocused ? `box-shadow: ${control.boxShadow} ${isInvalid ? color.dangerLight : control.boxShadowColor};` : ''), ({
  theme
}) => theme.control.css, ({
  isFocused,
  theme
}) => isFocused && theme.control.focusedCss);
const MenuWrapper = /*#__PURE__*/styled.div.withConfig({
  displayName: "MenuWrapper",
  componentId: "kcrmu9-3"
})(["z-index:999;cursor:default;position:absolute;", " ", " .", "{display:block;overflow:hidden;user-select:none;white-space:nowrap;text-overflow:ellipsis;-webkit-tap-highlight-color:transparent;", "}"], ({
  menuTop,
  menuOpen,
  theme: {
    menu
  }
}) => css(["width:", ";margin:", ";padding:", ";animation:", ";box-shadow:", ";border-radius:", ";background-color:", ";", " ", ""], menu.width, menu.margin, menu.padding, menu.animation, menu.boxShadow, menu.borderRadius, menu.backgroundColor, !menuOpen ? 'display: none;' : '', menuTop ? `top: ${menuTop};` : ''), ({
  theme
}) => theme.menu.css, OPTION_CLS, ({
  theme: {
    menu: {
      option
    }
  }
}) => css(["padding:", ";text-align:", ";&.", ",&:hover:not(.", "):not(.", "){background-color:", ";}&.", "{color:", ";background-color:", ";}&.", "{opacity:0.35;}"], option.padding, option.textAlign, OPTION_FOCUSED_CLS, OPTION_DISABLED_CLS, OPTION_SELECTED_CLS, option.focusedBgColor, OPTION_SELECTED_CLS, option.selectedColor, option.selectedBgColor, OPTION_DISABLED_CLS));
const Select = /*#__PURE__*/forwardRef(({
  async,
  isMulti,
  inputId,
  selectId,
  required,
  autoFocus,
  isLoading,
  onKeyDown,
  clearIcon,
  caretIcon,
  isInvalid,
  ariaLabel,
  menuWidth,
  isDisabled,
  inputDelay,
  onMenuOpen,
  onMenuClose,
  onInputBlur,
  isClearable,
  themeConfig,
  loadingNode,
  initialValue,
  onInputFocus,
  onInputChange,
  addClassNames,
  ariaLabelledBy,
  onOptionChange,
  onSearchChange,
  getOptionLabel,
  getOptionValue,
  itemKeySelector,
  openMenuOnFocus,
  isAriaLiveEnabled,
  menuOverscanCount,
  blurInputOnSelect,
  renderOptionLabel,
  renderMultiOptions,
  menuScrollDuration,
  filterIgnoreAccents,
  hideSelectedOptions,
  getIsOptionDisabled,
  getFilterOptionString,
  isSearchable: _isSearchable = true,
  openMenuOnClick: _openMenuOnClick = true,
  filterIgnoreCase: _filterIgnoreCase = true,
  tabSelectsOption: _tabSelectsOption = true,
  closeMenuOnSelect: _closeMenuOnSelect = true,
  scrollMenuIntoView: _scrollMenuIntoView = true,
  backspaceClearsValue: _backspaceClearsValue = true,
  filterMatchFrom: _filterMatchFrom = FilterMatchEnum.ANY,
  menuPosition: _menuPosition = MenuPositionEnum.BOTTOM,
  options: _options = EMPTY_ARRAY,
  loadingMsg: _loadingMsg = LOADING_MSG_DEFAULT,
  placeholder: _placeholder = PLACEHOLDER_DEFAULT,
  noOptionsMsg: _noOptionsMsg = NO_OPTIONS_MSG_DEFAULT,
  menuItemSize: _menuItemSize = MENU_ITEM_SIZE_DEFAULT,
  menuMaxHeight: _menuMaxHeight = MENU_MAX_HEIGHT_DEFAULT
}, ref) => {
  const menuOpenRef = useRef(false);
  const prevMenuOptionsLength = useRef();
  const onChangeEventValue = useRef(false);
  const listRef = useRef(null);
  const menuRef = useRef(null);
  const inputRef = useRef(null);
  const controlRef = useRef(null);
  const [inputValue, setInputValue] = useState('');
  const [menuOpen, setMenuOpen] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [focusedMultiValue, setFocusedMultiValue] = useState(NULL);
  const [focusedOption, setFocusedOption] = useState(FOCUSED_OPTION_DEFAULT);
  const theme = useMemo(() => {
    return isPlainObject(themeConfig) ? mergeDeep(RfsTheme, themeConfig) : RfsTheme;
  }, [themeConfig]);
  const getOptionLabelFn = useMemo(() => getOptionLabel || (data => data.label), [getOptionLabel]);
  const getOptionValueFn = useMemo(() => getOptionValue || (data => data.value), [getOptionValue]);
  const renderOptionLabelFn = useMemo(() => renderOptionLabel || getOptionLabelFn, [renderOptionLabel, getOptionLabelFn]);
  const debouncedInputValue = useDebounce(inputValue, inputDelay);
  const [selectedOption, setSelectedOption] = useState(() => normalizeValue(initialValue, getOptionValueFn, getOptionLabelFn));
  const menuOptions = useMenuOptions(_options, debouncedInputValue, _filterMatchFrom, selectedOption, getOptionValueFn, getOptionLabelFn, getIsOptionDisabled, getFilterOptionString, _filterIgnoreCase, filterIgnoreAccents, isMulti, hideSelectedOptions, async);
  const [menuStyleTop, menuHeightCalc] = useMenuPositioner(menuRef, controlRef, menuOpen, _menuPosition, _menuItemSize, _menuMaxHeight, menuOptions.length, menuScrollDuration, _scrollMenuIntoView, onMenuOpen, onMenuClose);

  const blurInput = () => {
    var _inputRef$current;

    return (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
  };

  const focusInput = () => {
    var _inputRef$current2;

    return (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.focus();
  };

  const scrollToItemIndex = index => {
    var _listRef$current;

    return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollToItem(index);
  };

  const handleMouseOrTouchEvent = (e, preventDefault) => {
    e.stopPropagation();
    preventDefault && e.preventDefault();
  };

  const removeSelectedOption = useCallback((removeValue, e) => {
    if (e) handleMouseOrTouchEvent(e, e.type === 'mousedown');
    setSelectedOption(prevSelectedOption => prevSelectedOption.filter(({
      value
    }) => value !== removeValue));
  }, []);
  const openMenuAndFocusOption = useCallback(position => {
    if (!isArrayWithLength(menuOptions)) {
      !menuOpenRef.current && setMenuOpen(true);
      return;
    }

    const selectedIndex = !isMulti ? menuOptions.findIndex(({
      isSelected
    }) => isSelected) : -1;
    const index = selectedIndex > -1 ? selectedIndex : position === OptionIndexEnum.FIRST ? 0 : menuOptions.length - 1;
    !menuOpenRef.current && setMenuOpen(true);
    setFocusedOption(_objectSpread$2({
      index
    }, menuOptions[index]));
    scrollToItemIndex(index);
  }, [isMulti, menuOptions]);
  const selectOption = useCallback((option, isSelected) => {
    if (isSelected) {
      isMulti && removeSelectedOption(option.value);
    } else {
      setSelectedOption(prevSelectedOption => !isMulti ? [option] : [...prevSelectedOption, option]);
    }

    const blurControl = typeof blurInputOnSelect === 'boolean' ? blurInputOnSelect : isTouchDevice();

    if (blurControl) {
      blurInput();
    } else if (_closeMenuOnSelect) {
      setMenuOpen(false);
      setInputValue('');
    }
  }, [isMulti, _closeMenuOnSelect, removeSelectedOption, blurInputOnSelect]);
  useImperativeHandle(ref, () => ({
    blur: blurInput,
    focus: focusInput,
    clearValue: () => {
      setSelectedOption(EMPTY_ARRAY);
      setFocusedOption(FOCUSED_OPTION_DEFAULT);
    },
    setValue: option => {
      const normalizedOptions = normalizeValue(option, getOptionValueFn, getOptionLabelFn);
      setSelectedOption(normalizedOptions);
    },
    toggleMenu: state => {
      if (state === true || state === undefined && !menuOpen) {
        !isFocused && focusInput();
        openMenuAndFocusOption(OptionIndexEnum.FIRST);
      } else {
        blurInput();
      }
    }
  }));
  useEffect(() => {
    autoFocus && focusInput();
  }, [autoFocus]);
  useEffect(() => {
    menuOpenRef.current = menuOpen;
  }, [menuOpen]);
  useEffect(() => {
    if (isFocused && openMenuOnFocus) {
      openMenuAndFocusOption(OptionIndexEnum.FIRST);
    }
  }, [isFocused, openMenuOnFocus, openMenuAndFocusOption]);
  useEffect(() => {
    if (onSearchChange && onChangeEventValue.current) {
      onChangeEventValue.current = false;
      onSearchChange(debouncedInputValue);
    }
  }, [onSearchChange, debouncedInputValue]);
  useUpdateEffect(() => {
    if (!onOptionChange) return;
    const normalizedOptionValue = isMulti ? selectedOption.map(({
      data
    }) => data) : isArrayWithLength(selectedOption) ? selectedOption[0].data : NULL;
    onOptionChange(normalizedOptionValue);
  }, [isMulti, selectedOption, onOptionChange]);
  useUpdateEffect(() => {
    const inputChanged = menuOptions.length > 0 && (async || menuOptions.length !== _options.length || prevMenuOptionsLength.current === 0);

    if (menuOptions.length === 0) {
      setFocusedOption(FOCUSED_OPTION_DEFAULT);
    } else if (menuOptions.length === 1 || inputChanged) {
      setFocusedOption(_objectSpread$2({
        index: 0
      }, menuOptions[0]));
      scrollToItemIndex(0);
    }

    prevMenuOptionsLength.current = menuOptions.length;
  }, [async, _options, menuOptions]);

  const selectOptionFromFocused = () => {
    const {
      data,
      value,
      label,
      isSelected,
      isDisabled: disabled
    } = focusedOption;

    if (data && !disabled) {
      selectOption({
        data,
        value,
        label
      }, isSelected);
    }
  };

  const focusValueOnArrowKey = direction => {
    if (!isArrayWithLength(selectedOption)) return;
    let nextFocusedIdx = -1;
    const lastValueIdx = selectedOption.length - 1;
    const curFocusedIdx = focusedMultiValue ? selectedOption.findIndex(x => x.value === focusedMultiValue) : -1;

    switch (direction) {
      case ValueIndexEnum.NEXT:
        nextFocusedIdx = curFocusedIdx > -1 && curFocusedIdx < lastValueIdx ? curFocusedIdx + 1 : -1;
        break;

      case ValueIndexEnum.PREVIOUS:
        nextFocusedIdx = curFocusedIdx !== 0 ? curFocusedIdx === -1 ? lastValueIdx : curFocusedIdx - 1 : 0;
        break;
    }

    const nextFocusedVal = nextFocusedIdx >= 0 ? selectedOption[nextFocusedIdx].value : NULL;
    if (focusedOption.data) setFocusedOption(FOCUSED_OPTION_DEFAULT);
    if (nextFocusedVal !== focusedMultiValue) setFocusedMultiValue(nextFocusedVal);
  };

  const focusOptionOnArrowKey = direction => {
    if (!isArrayWithLength(menuOptions)) return;
    const index = direction === OptionIndexEnum.DOWN ? (focusedOption.index + 1) % menuOptions.length : focusedOption.index > 0 ? focusedOption.index - 1 : menuOptions.length - 1;
    focusedMultiValue && setFocusedMultiValue(NULL);
    setFocusedOption(_objectSpread$2({
      index
    }, menuOptions[index]));
    scrollToItemIndex(index);
  };

  const handleOnKeyDown = e => {
    if (isDisabled) return;

    if (onKeyDown) {
      onKeyDown(e, inputValue, focusedOption);
      if (e.defaultPrevented) return;
    }

    switch (e.key) {
      case 'ArrowDown':
      case 'ArrowUp':
        const downKey = e.key === 'ArrowDown';
        menuOpen ? focusOptionOnArrowKey(downKey ? OptionIndexEnum.DOWN : OptionIndexEnum.UP) : openMenuAndFocusOption(downKey ? OptionIndexEnum.FIRST : OptionIndexEnum.LAST);
        break;

      case 'ArrowLeft':
      case 'ArrowRight':
        if (!isMulti || inputValue || renderMultiOptions) return;
        focusValueOnArrowKey(e.key === 'ArrowLeft' ? ValueIndexEnum.PREVIOUS : ValueIndexEnum.NEXT);
        break;

      case ' ':
        if (inputValue) {
          return;
        } else if (!menuOpen) {
          openMenuAndFocusOption(OptionIndexEnum.FIRST);
        } else if (!focusedOption.data) {
          return;
        } else {
          selectOptionFromFocused();
        }

        break;

      case 'Enter':
        if (menuOpen && e.keyCode !== 229) {
          selectOptionFromFocused();
        }

        break;

      case 'Escape':
        if (menuOpen) {
          setMenuOpen(false);
          setInputValue('');
        }

        break;

      case 'Tab':
        if (!menuOpen || !_tabSelectsOption || !focusedOption.data || e.shiftKey) return;
        selectOptionFromFocused();
        break;

      case 'Delete':
      case 'Backspace':
        if (inputValue) return;

        if (focusedMultiValue) {
          const clearFocusedIndex = selectedOption.findIndex(({
            value
          }) => value === focusedMultiValue);
          const nexFocusedMultiValue = clearFocusedIndex > -1 && clearFocusedIndex < selectedOption.length - 1 ? selectedOption[clearFocusedIndex + 1].value : NULL;
          removeSelectedOption(focusedMultiValue);
          setFocusedMultiValue(nexFocusedMultiValue);
        } else {
          if (!_backspaceClearsValue) return;

          if (isArrayWithLength(selectedOption)) {
            if (isMulti && !renderMultiOptions) {
              const {
                value
              } = selectedOption[selectedOption.length - 1];
              removeSelectedOption(value);
            } else if (isClearable) {
              setSelectedOption(EMPTY_ARRAY);
            }
          }
        }

        break;

      default:
        return;
    }

    e.preventDefault();
  };

  const handleOnControlMouseDown = e => {
    if (isDisabled) return;
    if (!isFocused) focusInput();
    const tagIsNotInput = e.currentTarget.tagName !== 'INPUT';

    if (!menuOpen) {
      _openMenuOnClick && openMenuAndFocusOption(OptionIndexEnum.FIRST);
    } else if (tagIsNotInput) {
      menuOpen && setMenuOpen(false);
      inputValue && setInputValue('');
    }

    if (tagIsNotInput) e.preventDefault();
  };

  const handleOnMenuMouseDown = e => {
    handleMouseOrTouchEvent(e, true);
    focusInput();
  };

  const handleOnInputBlur = useCallback(e => {
    onInputBlur === null || onInputBlur === void 0 ? void 0 : onInputBlur(e);
    setIsFocused(false);
    setMenuOpen(false);
    setInputValue('');
  }, [onInputBlur]);
  const handleOnInputFocus = useCallback(e => {
    onInputFocus === null || onInputFocus === void 0 ? void 0 : onInputFocus(e);
    setIsFocused(true);
  }, [onInputFocus]);
  const handleOnInputChange = useCallback(e => {
    onChangeEventValue.current = true;
    const inputVal = e.currentTarget.value || '';
    onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(inputVal);
    !menuOpenRef.current && setMenuOpen(true);
    setInputValue(inputVal);
  }, [onInputChange]);
  const handleOnClearMouseDown = useCallback(e => {
    handleMouseOrTouchEvent(e, e.type === 'mousedown');
    setSelectedOption(EMPTY_ARRAY);
    focusInput();
  }, []);
  const handleOnCaretMouseDown = useCallback(e => {
    handleMouseOrTouchEvent(e, e.type === 'mousedown');
    focusInput();
    menuOpenRef.current ? setMenuOpen(false) : openMenuAndFocusOption(OptionIndexEnum.FIRST);
  }, [openMenuAndFocusOption]);
  return /*#__PURE__*/React.createElement(ThemeProvider, {
    theme: theme
  }, /*#__PURE__*/React.createElement(SelectWrapper, {
    id: selectId,
    role: 'combobox',
    "aria-haspopup": 'listbox',
    "aria-controls": inputId,
    "aria-expanded": menuOpen,
    onKeyDown: handleOnKeyDown,
    "data-testid": SELECT_CONTAINER_TESTID,
    className: addClassNames ? SELECT_CONTAINER_CLS : undefined
  }, /*#__PURE__*/React.createElement(ControlWrapper, {
    ref: controlRef,
    isInvalid: isInvalid,
    isFocused: isFocused,
    isDisabled: isDisabled,
    onTouchEnd: handleOnControlMouseDown,
    onMouseDown: handleOnControlMouseDown,
    "data-testid": CONTROL_CONTAINER_TESTID,
    className: addClassNames ? CONTROL_CONTAINER_CLS : undefined
  }, /*#__PURE__*/React.createElement(ValueWrapper, null, /*#__PURE__*/React.createElement(Value, {
    isMulti: isMulti,
    inputValue: inputValue,
    placeholder: _placeholder,
    selectedOption: selectedOption,
    focusedMultiValue: focusedMultiValue,
    renderOptionLabel: renderOptionLabelFn,
    renderMultiOptions: renderMultiOptions,
    removeSelectedOption: removeSelectedOption
  }), /*#__PURE__*/React.createElement(AutosizeInput, {
    id: inputId,
    ref: inputRef,
    required: required,
    ariaLabel: ariaLabel,
    inputValue: inputValue,
    onBlur: handleOnInputBlur,
    onFocus: handleOnInputFocus,
    addClassNames: addClassNames,
    onChange: handleOnInputChange,
    ariaLabelledBy: ariaLabelledBy,
    selectedOption: selectedOption,
    readOnly: isDisabled || !_isSearchable || !!focusedMultiValue
  })), /*#__PURE__*/React.createElement(IndicatorIcons, {
    menuOpen: menuOpen,
    clearIcon: clearIcon,
    caretIcon: caretIcon,
    isInvalid: isInvalid,
    isLoading: isLoading,
    isDisabled: isDisabled,
    loadingNode: loadingNode,
    addClassNames: addClassNames,
    onClearMouseDown: handleOnClearMouseDown,
    showClear: !!(isClearable && !isDisabled && isArrayWithLength(selectedOption)),
    onCaretMouseDown: !isDisabled && !_openMenuOnClick ? handleOnCaretMouseDown : undefined
  })), /*#__PURE__*/React.createElement(MenuWrapper, {
    ref: menuRef,
    menuOpen: menuOpen,
    menuTop: menuStyleTop,
    onMouseDown: handleOnMenuMouseDown,
    "data-testid": MENU_CONTAINER_TESTID,
    className: addClassNames ? MENU_CONTAINER_CLS : undefined
  }, /*#__PURE__*/React.createElement(Menu, {
    ref: listRef,
    isLoading: isLoading,
    height: menuHeightCalc,
    itemSize: _menuItemSize,
    loadingMsg: _loadingMsg,
    menuOptions: menuOptions,
    noOptionsMsg: _noOptionsMsg,
    selectOption: selectOption,
    itemKeySelector: itemKeySelector,
    overscanCount: menuOverscanCount,
    width: menuWidth || theme.menu.width,
    renderOptionLabel: renderOptionLabelFn,
    focusedOptionIndex: focusedOption.index
  })), isAriaLiveEnabled && /*#__PURE__*/React.createElement(AriaLiveRegion, {
    menuOpen: menuOpen,
    isFocused: isFocused,
    ariaLabel: ariaLabel,
    inputValue: inputValue,
    isSearchable: _isSearchable,
    focusedOption: focusedOption,
    selectedOption: selectedOption,
    optionCount: menuOptions.length
  })));
});
Select.displayName = 'Select';

export { FilterMatchEnum, MenuPositionEnum, Select };
