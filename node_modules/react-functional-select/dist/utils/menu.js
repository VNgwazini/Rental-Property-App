function getScrollTop(el) {
    return isDocumentElement(el) ? window.pageYOffset : el.scrollTop;
}
function scrollTo(el, top) {
    isDocumentElement(el) ? window.scrollTo(0, top) : (el.scrollTop = top);
}
function isDocumentElement(el) {
    return el === document.documentElement || el === document.body || el === window;
}
function styleHasOverlfow(style) {
    const { overflow, overflowX, overflowY } = style;
    const isOverflow = (x) => x === 'auto' || x === 'scroll';
    return isOverflow(overflow) || isOverflow(overflowX) || isOverflow(overflowY);
}
function getScrollParent(el) {
    let style = getComputedStyle(el);
    const excludeStaticParent = style.position === 'absolute';
    if (style.position === 'fixed') {
        return document.documentElement;
    }
    for (let parent = el; (parent = parent ? parent.parentElement : null);) {
        style = getComputedStyle(parent);
        if (!(excludeStaticParent && style.position === 'static') && styleHasOverlfow(style)) {
            return parent;
        }
    }
    return document.documentElement;
}
const smoothScrollTo = (el, to, duration = 300, callback) => {
    let currentTime = 0;
    const start = getScrollTop(el);
    const change = to - start;
    const easeOutCubic = (t) => change * ((t = t / duration - 1) * t * t + 1) + start;
    const smoothScroller = () => {
        currentTime += 5;
        scrollTo(el, easeOutCubic(currentTime));
        (currentTime < duration)
            ? window.requestAnimationFrame(smoothScroller)
            : callback?.();
    };
    window.requestAnimationFrame(smoothScroller);
};
export const calculateMenuTop = (menuHeight, menuEl, controlEl) => {
    const menuHeightOrDefault = (menuHeight > 0 || !menuEl)
        ? menuHeight
        : menuEl.getBoundingClientRect().height;
    const controlHeight = controlEl ? controlEl.getBoundingClientRect().height : 0;
    const menuElStyle = menuEl && getComputedStyle(menuEl);
    const marginBottom = menuElStyle ? parseInt(menuElStyle.marginBottom, 10) : 0;
    const marginTop = menuElStyle ? parseInt(menuElStyle.marginTop, 10) : 0;
    const basePx = -Math.abs(menuHeightOrDefault + controlHeight);
    const adjustPx = marginBottom + marginTop;
    return 'calc(' + basePx + 'px' + adjustPx + 'px)';
};
export const menuFitsBelowControl = (el) => {
    if (!el)
        return true;
    const scrollParent = getScrollParent(el);
    const { top, height } = el.getBoundingClientRect();
    const scrollSpaceBelow = scrollParent.getBoundingClientRect().height - getScrollTop(scrollParent) - top;
    return scrollSpaceBelow >= height;
};
export const scrollMenuIntoViewOnOpen = (menuEl, menuScrollDuration, scrollMenuIntoView, handleOnMenuOpen) => {
    if (!menuEl) {
        handleOnMenuOpen();
        return;
    }
    const { top, height, bottom } = menuEl.getBoundingClientRect();
    const viewInner = window.innerHeight;
    const viewSpaceBelow = viewInner - top;
    if (viewSpaceBelow >= height) {
        handleOnMenuOpen();
        return;
    }
    const scrollParent = getScrollParent(menuEl);
    const scrollTop = getScrollTop(scrollParent);
    const scrollSpaceBelow = scrollParent.getBoundingClientRect().height - scrollTop - top;
    const notEnoughSpaceBelow = scrollSpaceBelow < height;
    if (notEnoughSpaceBelow || !scrollMenuIntoView) {
        const condensedMenuHeight = notEnoughSpaceBelow ? scrollSpaceBelow : undefined;
        handleOnMenuOpen(condensedMenuHeight);
        return;
    }
    const marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
    const scrollDown = bottom - viewInner + scrollTop + marginBottom;
    smoothScrollTo(scrollParent, scrollDown, menuScrollDuration, handleOnMenuOpen);
};
