import { SELECTED_OPTION_DEFAULT } from './constants/defaults';
import { OVERFLOW_REGEXP, DIACRITICS_REGEXP, IE_EDGE_BROWSER_REGEXP } from './constants/regexp';
import { OPTION_CLS, OPTION_FOCUSED_CLS, OPTION_SELECTED_CLS, OPTION_DISABLED_CLS } from './constants/dom';
function isDocumentElement(el) {
    return (el === document.documentElement ||
        el === document.body ||
        el === window);
}
function stripDiacritics(value) {
    return value.normalize('NFD').replace(DIACRITICS_REGEXP, '');
}
function easeOutCubic(t, s, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + s;
}
function getScrollTop(el) {
    return isDocumentElement(el) ? window.pageYOffset : el.scrollTop;
}
function scrollTo(el, top) {
    isDocumentElement(el) ? window.scrollTo(0, top) : el.scrollTop = top;
}
function getScrollParent(el) {
    let style = getComputedStyle(el);
    const excludeStaticParent = (style.position === 'absolute');
    if (style.position === 'fixed') {
        return document.documentElement;
    }
    for (let parent = el; (parent = parent ? parent.parentElement : null);) {
        style = getComputedStyle(parent);
        if (!(excludeStaticParent && style.position === 'static') &&
            OVERFLOW_REGEXP.test(`${style.overflow}${style.overflowY}${style.overflowX}`)) {
            return parent;
        }
    }
    return document.documentElement;
}
function smoothScrollTo(element, to, duration = 300, callback) {
    let currentTime = 0;
    const start = getScrollTop(element);
    const change = (to - start);
    function smoothScroller() {
        currentTime += 5;
        scrollTo(element, easeOutCubic(currentTime, start, change, duration));
        if (currentTime < duration) {
            window.requestAnimationFrame(smoothScroller);
        }
        else {
            callback && callback();
        }
    }
    window.requestAnimationFrame(smoothScroller);
}
export const isEdgeOrIE = () => (typeof navigator !== 'undefined') && IE_EDGE_BROWSER_REGEXP.test(navigator.userAgent);
export const isTouchDevice = () => (typeof window !== 'undefined' && 'ontouchstart' in window) || (typeof navigator !== 'undefined' && !!navigator.maxTouchPoints);
export function isArrayWithLength(test) {
    return Array.isArray(test) && !!test.length;
}
export function isPlainObject(test) {
    return test && (typeof test === 'object') && !Array.isArray(test);
}
export function optionClassName(isDisabled, isSelected, isFocused) {
    let className = OPTION_CLS;
    if (isDisabled)
        className += (' ' + OPTION_DISABLED_CLS);
    if (isSelected)
        className += (' ' + OPTION_SELECTED_CLS);
    if (isFocused)
        className += (' ' + OPTION_FOCUSED_CLS);
    return className;
}
export function trimAndFormatFilterStr(value, filterIgnoreCase, filterIgnoreAccents) {
    let trimVal = value.trim();
    if (filterIgnoreCase) {
        trimVal = trimVal.toLowerCase();
    }
    return !filterIgnoreAccents ? trimVal : stripDiacritics(trimVal);
}
export function mergeDeep(target, source) {
    const output = { ...target };
    Object.keys(source).forEach((key) => {
        output[key] =
            (isPlainObject(source[key]) && key !== 'animation')
                ? (key in target)
                    ? mergeDeep(target[key], source[key])
                    : source[key]
                : source[key] || '';
    });
    return output;
}
export const calculateMenuTop = (menuHeight, menuEl, controlEl) => {
    const menuHeightOrDefault = (menuHeight > 0 || !menuEl) ? menuHeight : menuEl.getBoundingClientRect().height;
    const controlHeight = controlEl ? controlEl.getBoundingClientRect().height : 0;
    const menuElStyle = menuEl && getComputedStyle(menuEl);
    const marginBottom = menuElStyle ? parseInt(menuElStyle.marginBottom || '0', 10) : 0;
    const marginTop = menuElStyle ? parseInt(menuElStyle.marginTop || '0', 10) : 0;
    return `calc(${-Math.abs(menuHeightOrDefault + controlHeight)}px + ${marginBottom + marginTop}px)`;
};
export function menuFitsBelowControl(menuEl) {
    if (!menuEl)
        return true;
    const menuRect = menuEl.getBoundingClientRect();
    const scrollParent = getScrollParent(menuEl);
    const scrollTop = getScrollTop(scrollParent);
    const scrollSpaceBelow = (scrollParent.getBoundingClientRect().height - scrollTop - menuRect.top);
    return (scrollSpaceBelow >= menuRect.height);
}
export function scrollMenuIntoViewOnOpen(menuEl, menuScrollDuration, scrollMenuIntoView, handleOnMenuOpen) {
    if (!menuEl) {
        handleOnMenuOpen();
        return;
    }
    const viewInner = window.innerHeight;
    const menuRect = menuEl.getBoundingClientRect();
    const viewSpaceBelow = viewInner - menuRect.top;
    if (viewSpaceBelow >= menuRect.height) {
        handleOnMenuOpen();
        return;
    }
    const scrollParent = getScrollParent(menuEl);
    const scrollTop = getScrollTop(scrollParent);
    const scrollSpaceBelow = (scrollParent.getBoundingClientRect().height - scrollTop - menuRect.top);
    const notEnoughSpaceBelow = scrollSpaceBelow < menuRect.height;
    if (notEnoughSpaceBelow || !scrollMenuIntoView) {
        const condensedMenuHeight = notEnoughSpaceBelow ? scrollSpaceBelow : undefined;
        handleOnMenuOpen(condensedMenuHeight);
        return;
    }
    const marginBottom = parseInt(getComputedStyle(menuEl).marginBottom || '0', 10);
    const scrollDown = (menuRect.bottom - viewInner + scrollTop + marginBottom);
    smoothScrollTo(scrollParent, scrollDown, menuScrollDuration, handleOnMenuOpen);
}
export function normalizeValue(value, getOptionValue, getOptionLabel) {
    const initialValues = Array.isArray(value)
        ? value
        : isPlainObject(value)
            ? [value]
            : SELECTED_OPTION_DEFAULT;
    return isArrayWithLength(initialValues)
        ? initialValues.map((x) => ({
            data: x,
            value: getOptionValue(x),
            label: getOptionLabel(x)
        }))
        : initialValues;
}
