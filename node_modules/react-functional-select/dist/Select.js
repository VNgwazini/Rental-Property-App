import React, { forwardRef, useEffect, useMemo, useState, useCallback, useRef, useImperativeHandle } from 'react';
import { RfsTheme } from './theme';
import styled, { css, ThemeProvider } from 'styled-components';
import { Menu, Value, AutosizeInput, IndicatorIcons, AriaLiveRegion } from './components';
import { useDebounce, useMenuPositioner, useMenuOptions, useUpdateEffect } from './hooks';
import { mergeDeep, isTouchDevice, isPlainObject, normalizeValue, isArrayWithLength } from './utils';
import { MenuPositionEnum, FilterMatchEnum, ValueIndexEnum, OptionIndexEnum } from './constants/enums';
import { NULL, EMPTY_ARRAY, LOADING_MSG_DEFAULT, PLACEHOLDER_DEFAULT, FOCUSED_OPTION_DEFAULT, NO_OPTIONS_MSG_DEFAULT, MENU_ITEM_SIZE_DEFAULT, MENU_MAX_HEIGHT_DEFAULT } from './constants/defaults';
import { OPTION_CLS, OPTION_FOCUSED_CLS, MENU_CONTAINER_CLS, OPTION_DISABLED_CLS, OPTION_SELECTED_CLS, SELECT_CONTAINER_CLS, CONTROL_CONTAINER_CLS, MENU_CONTAINER_TESTID, SELECT_CONTAINER_TESTID, CONTROL_CONTAINER_TESTID } from './constants/dom';
;
;
const SelectWrapper = styled.div `
  position: relative;
  box-sizing: border-box;
  ${({ theme }) => theme.select.css}
`;
const ValueWrapper = styled.div `
  flex: 1 1 0%;
  display: flex;
  flex-wrap: wrap;
  overflow: hidden;
  position: relative;
  align-items: center;
  box-sizing: border-box;
  padding: ${({ theme }) => theme.control.padding};
`;
const ControlWrapper = styled.div `
  outline: 0;
  display: flex;
  flex-wrap: wrap;
  cursor: default;
  position: relative;
  align-items: center;
  box-sizing: border-box;
  justify-content: space-between;

  ${({ isDisabled, isFocused, isInvalid, theme: { control, color } }) => css `
    transition: ${control.transition};
    border-style: ${control.borderStyle};
    border-width: ${control.borderWidth};
    border-radius: ${control.borderRadius};
    min-height: ${control.height || control.minHeight};

    border-color: ${isInvalid
    ? color.danger
    : isFocused
        ? control.focusedBorderColor
        : color.border};

    ${isDisabled ? 'pointer-events: none;' : ''}
    ${control.height ? `height: ${control.height};` : ''}

    ${control.backgroundColor || isDisabled
    ? `background-color: ${isDisabled ? color.disabled : control.backgroundColor};`
    : ''}

    ${isFocused
    ? `box-shadow: ${control.boxShadow} ${isInvalid ? color.dangerLight : control.boxShadowColor};`
    : ''}
  `}

  ${({ theme }) => theme.control.css}
  ${({ isFocused, theme }) => isFocused && theme.control.focusedCss}
`;
const MenuWrapper = styled.div `
  z-index: 999;
  cursor: default;
  position: absolute;

  ${({ menuTop, menuOpen, theme: { menu } }) => css `
    width: ${menu.width};
    margin: ${menu.margin};
    padding: ${menu.padding};
    animation: ${menu.animation};
    box-shadow: ${menu.boxShadow};
    border-radius: ${menu.borderRadius};
    background-color: ${menu.backgroundColor};
    ${!menuOpen ? 'display: none;' : ''}
    ${menuTop ? `top: ${menuTop};` : ''}
  `}

  ${({ theme }) => theme.menu.css}

  .${OPTION_CLS} {
    display: block;
    overflow: hidden;
    user-select: none;
    white-space: nowrap;
    text-overflow: ellipsis;
    -webkit-tap-highlight-color: transparent;

    ${({ theme: { menu: { option } } }) => css `
      padding: ${option.padding};
      text-align: ${option.textAlign};

      &.${OPTION_FOCUSED_CLS},
      &:hover:not(.${OPTION_DISABLED_CLS}):not(.${OPTION_SELECTED_CLS}) {
        background-color: ${option.focusedBgColor};
      }

      &.${OPTION_SELECTED_CLS} {
        color: ${option.selectedColor};
        background-color: ${option.selectedBgColor};
      }

      &.${OPTION_DISABLED_CLS} {
        opacity: 0.35;
      }
    `}
  }
`;
const Select = forwardRef(({ async, isMulti, inputId, selectId, required, autoFocus, isLoading, onKeyDown, clearIcon, caretIcon, isInvalid, ariaLabel, menuWidth, isDisabled, inputDelay, onMenuOpen, onMenuClose, onInputBlur, isClearable, themeConfig, loadingNode, initialValue, onInputFocus, onInputChange, addClassNames, ariaLabelledBy, onOptionChange, onSearchChange, getOptionLabel, getOptionValue, itemKeySelector, openMenuOnFocus, isAriaLiveEnabled, menuOverscanCount, blurInputOnSelect, renderOptionLabel, renderMultiOptions, menuScrollDuration, filterIgnoreAccents, hideSelectedOptions, getIsOptionDisabled, getFilterOptionString, isSearchable = true, openMenuOnClick = true, filterIgnoreCase = true, tabSelectsOption = true, closeMenuOnSelect = true, scrollMenuIntoView = true, backspaceClearsValue = true, filterMatchFrom = FilterMatchEnum.ANY, menuPosition = MenuPositionEnum.BOTTOM, options = EMPTY_ARRAY, loadingMsg = LOADING_MSG_DEFAULT, placeholder = PLACEHOLDER_DEFAULT, noOptionsMsg = NO_OPTIONS_MSG_DEFAULT, menuItemSize = MENU_ITEM_SIZE_DEFAULT, menuMaxHeight = MENU_MAX_HEIGHT_DEFAULT }, ref) => {
    const menuOpenRef = useRef(false);
    const prevMenuOptionsLength = useRef();
    const onChangeEventValue = useRef(false);
    const listRef = useRef(null);
    const menuRef = useRef(null);
    const inputRef = useRef(null);
    const controlRef = useRef(null);
    const [inputValue, setInputValue] = useState('');
    const [menuOpen, setMenuOpen] = useState(false);
    const [isFocused, setIsFocused] = useState(false);
    const [focusedMultiValue, setFocusedMultiValue] = useState(NULL);
    const [focusedOption, setFocusedOption] = useState(FOCUSED_OPTION_DEFAULT);
    const theme = useMemo(() => {
        return isPlainObject(themeConfig) ? mergeDeep(RfsTheme, themeConfig) : RfsTheme;
    }, [themeConfig]);
    const getOptionLabelFn = useMemo(() => getOptionLabel || ((data) => data.label), [getOptionLabel]);
    const getOptionValueFn = useMemo(() => getOptionValue || ((data) => data.value), [getOptionValue]);
    const renderOptionLabelFn = useMemo(() => renderOptionLabel || getOptionLabelFn, [renderOptionLabel, getOptionLabelFn]);
    const debouncedInputValue = useDebounce(inputValue, inputDelay);
    const [selectedOption, setSelectedOption] = useState(() => normalizeValue(initialValue, getOptionValueFn, getOptionLabelFn));
    const menuOptions = useMenuOptions(options, debouncedInputValue, filterMatchFrom, selectedOption, getOptionValueFn, getOptionLabelFn, getIsOptionDisabled, getFilterOptionString, filterIgnoreCase, filterIgnoreAccents, isMulti, hideSelectedOptions, async);
    const [menuStyleTop, menuHeightCalc] = useMenuPositioner(menuRef, controlRef, menuOpen, menuPosition, menuItemSize, menuMaxHeight, menuOptions.length, menuScrollDuration, scrollMenuIntoView, onMenuOpen, onMenuClose);
    const blurInput = () => inputRef.current?.blur();
    const focusInput = () => inputRef.current?.focus();
    const scrollToItemIndex = (index) => listRef.current?.scrollToItem(index);
    const handleMouseOrTouchEvent = (e, preventDefault) => {
        e.stopPropagation();
        preventDefault && e.preventDefault();
    };
    const removeSelectedOption = useCallback((removeValue, e) => {
        if (e)
            handleMouseOrTouchEvent(e, e.type === 'mousedown');
        setSelectedOption((prevSelectedOption) => prevSelectedOption.filter(({ value }) => value !== removeValue));
    }, []);
    const openMenuAndFocusOption = useCallback((position) => {
        if (!isArrayWithLength(menuOptions)) {
            !menuOpenRef.current && setMenuOpen(true);
            return;
        }
        const selectedIndex = !isMulti
            ? menuOptions.findIndex(({ isSelected }) => isSelected)
            : -1;
        const index = (selectedIndex > -1)
            ? selectedIndex
            : (position === OptionIndexEnum.FIRST)
                ? 0
                : (menuOptions.length - 1);
        !menuOpenRef.current && setMenuOpen(true);
        setFocusedOption({ index, ...menuOptions[index] });
        scrollToItemIndex(index);
    }, [isMulti, menuOptions]);
    const selectOption = useCallback((option, isSelected) => {
        if (isSelected) {
            isMulti && removeSelectedOption(option.value);
        }
        else {
            setSelectedOption((prevSelectedOption) => !isMulti ? [option] : [...prevSelectedOption, option]);
        }
        const blurControl = (typeof blurInputOnSelect === 'boolean')
            ? blurInputOnSelect
            : isTouchDevice();
        if (blurControl) {
            blurInput();
        }
        else if (closeMenuOnSelect) {
            setMenuOpen(false);
            setInputValue('');
        }
    }, [isMulti, closeMenuOnSelect, removeSelectedOption, blurInputOnSelect]);
    useImperativeHandle(ref, () => ({
        blur: blurInput,
        focus: focusInput,
        clearValue: () => {
            setSelectedOption(EMPTY_ARRAY);
            setFocusedOption(FOCUSED_OPTION_DEFAULT);
        },
        setValue: (option) => {
            const normalizedOptions = normalizeValue(option, getOptionValueFn, getOptionLabelFn);
            setSelectedOption(normalizedOptions);
        },
        toggleMenu: (state) => {
            if (state === true || (state === undefined && !menuOpen)) {
                !isFocused && focusInput();
                openMenuAndFocusOption(OptionIndexEnum.FIRST);
            }
            else {
                blurInput();
            }
        },
    }));
    useEffect(() => {
        autoFocus && focusInput();
    }, [autoFocus]);
    useEffect(() => {
        menuOpenRef.current = menuOpen;
    }, [menuOpen]);
    useEffect(() => {
        if (isFocused && openMenuOnFocus) {
            openMenuAndFocusOption(OptionIndexEnum.FIRST);
        }
    }, [isFocused, openMenuOnFocus, openMenuAndFocusOption]);
    useEffect(() => {
        if (onSearchChange && onChangeEventValue.current) {
            onChangeEventValue.current = false;
            onSearchChange(debouncedInputValue);
        }
    }, [onSearchChange, debouncedInputValue]);
    useUpdateEffect(() => {
        if (!onOptionChange)
            return;
        const normalizedOptionValue = isMulti
            ? selectedOption.map(({ data }) => data)
            : isArrayWithLength(selectedOption)
                ? selectedOption[0].data
                : NULL;
        onOptionChange(normalizedOptionValue);
    }, [isMulti, selectedOption, onOptionChange]);
    useUpdateEffect(() => {
        const inputChanged = menuOptions.length > 0 &&
            (async || menuOptions.length !== options.length || prevMenuOptionsLength.current === 0);
        if (menuOptions.length === 0) {
            setFocusedOption(FOCUSED_OPTION_DEFAULT);
        }
        else if (menuOptions.length === 1 || inputChanged) {
            setFocusedOption({ index: 0, ...menuOptions[0] });
            scrollToItemIndex(0);
        }
        prevMenuOptionsLength.current = menuOptions.length;
    }, [async, options, menuOptions]);
    const selectOptionFromFocused = () => {
        const { data, value, label, isSelected, isDisabled: disabled } = focusedOption;
        if (data && !disabled) {
            selectOption({ data, value, label }, isSelected);
        }
    };
    const focusValueOnArrowKey = (direction) => {
        if (!isArrayWithLength(selectedOption))
            return;
        let nextFocusedIdx = -1;
        const lastValueIdx = selectedOption.length - 1;
        const curFocusedIdx = focusedMultiValue ? selectedOption.findIndex((x) => x.value === focusedMultiValue) : -1;
        switch (direction) {
            case ValueIndexEnum.NEXT:
                nextFocusedIdx = (curFocusedIdx > -1 && curFocusedIdx < lastValueIdx)
                    ? (curFocusedIdx + 1)
                    : -1;
                break;
            case ValueIndexEnum.PREVIOUS:
                nextFocusedIdx =
                    curFocusedIdx !== 0
                        ? curFocusedIdx === -1
                            ? lastValueIdx
                            : curFocusedIdx - 1
                        : 0;
                break;
        }
        const nextFocusedVal = (nextFocusedIdx >= 0)
            ? selectedOption[nextFocusedIdx].value
            : NULL;
        if (focusedOption.data)
            setFocusedOption(FOCUSED_OPTION_DEFAULT);
        if (nextFocusedVal !== focusedMultiValue)
            setFocusedMultiValue(nextFocusedVal);
    };
    const focusOptionOnArrowKey = (direction) => {
        if (!isArrayWithLength(menuOptions))
            return;
        const index = direction === OptionIndexEnum.DOWN
            ? ((focusedOption.index + 1) % menuOptions.length)
            : focusedOption.index > 0
                ? focusedOption.index - 1
                : menuOptions.length - 1;
        focusedMultiValue && setFocusedMultiValue(NULL);
        setFocusedOption({ index, ...menuOptions[index] });
        scrollToItemIndex(index);
    };
    const handleOnKeyDown = (e) => {
        if (isDisabled)
            return;
        if (onKeyDown) {
            onKeyDown(e, inputValue, focusedOption);
            if (e.defaultPrevented)
                return;
        }
        switch (e.key) {
            case 'ArrowDown':
            case 'ArrowUp':
                const downKey = e.key === 'ArrowDown';
                menuOpen
                    ? focusOptionOnArrowKey(downKey ? OptionIndexEnum.DOWN : OptionIndexEnum.UP)
                    : openMenuAndFocusOption(downKey ? OptionIndexEnum.FIRST : OptionIndexEnum.LAST);
                break;
            case 'ArrowLeft':
            case 'ArrowRight':
                if (!isMulti || inputValue || renderMultiOptions)
                    return;
                focusValueOnArrowKey((e.key === 'ArrowLeft') ? ValueIndexEnum.PREVIOUS : ValueIndexEnum.NEXT);
                break;
            case ' ':
                if (inputValue) {
                    return;
                }
                else if (!menuOpen) {
                    openMenuAndFocusOption(OptionIndexEnum.FIRST);
                }
                else if (!focusedOption.data) {
                    return;
                }
                else {
                    selectOptionFromFocused();
                }
                break;
            case 'Enter':
                if (menuOpen && e.keyCode !== 229) {
                    selectOptionFromFocused();
                }
                break;
            case 'Escape':
                if (menuOpen) {
                    setMenuOpen(false);
                    setInputValue('');
                }
                break;
            case 'Tab':
                if (!menuOpen || !tabSelectsOption || !focusedOption.data || e.shiftKey)
                    return;
                selectOptionFromFocused();
                break;
            case 'Delete':
            case 'Backspace':
                if (inputValue)
                    return;
                if (focusedMultiValue) {
                    const clearFocusedIndex = selectedOption.findIndex(({ value }) => value === focusedMultiValue);
                    const nexFocusedMultiValue = (clearFocusedIndex > -1 && (clearFocusedIndex < (selectedOption.length - 1)))
                        ? selectedOption[clearFocusedIndex + 1].value
                        : NULL;
                    removeSelectedOption(focusedMultiValue);
                    setFocusedMultiValue(nexFocusedMultiValue);
                }
                else {
                    if (!backspaceClearsValue)
                        return;
                    if (isArrayWithLength(selectedOption)) {
                        if (isMulti && !renderMultiOptions) {
                            const { value } = selectedOption[selectedOption.length - 1];
                            removeSelectedOption(value);
                        }
                        else if (isClearable) {
                            setSelectedOption(EMPTY_ARRAY);
                        }
                    }
                }
                break;
            default:
                return;
        }
        e.preventDefault();
    };
    const handleOnControlMouseDown = (e) => {
        if (isDisabled)
            return;
        if (!isFocused)
            focusInput();
        const tagIsNotInput = (e.currentTarget.tagName !== 'INPUT');
        if (!menuOpen) {
            openMenuOnClick && openMenuAndFocusOption(OptionIndexEnum.FIRST);
        }
        else if (tagIsNotInput) {
            menuOpen && setMenuOpen(false);
            inputValue && setInputValue('');
        }
        if (tagIsNotInput)
            e.preventDefault();
    };
    const handleOnMenuMouseDown = (e) => {
        handleMouseOrTouchEvent(e, true);
        focusInput();
    };
    const handleOnInputBlur = useCallback((e) => {
        onInputBlur?.(e);
        setIsFocused(false);
        setMenuOpen(false);
        setInputValue('');
    }, [onInputBlur]);
    const handleOnInputFocus = useCallback((e) => {
        onInputFocus?.(e);
        setIsFocused(true);
    }, [onInputFocus]);
    const handleOnInputChange = useCallback((e) => {
        onChangeEventValue.current = true;
        const inputVal = e.currentTarget.value || '';
        onInputChange?.(inputVal);
        !menuOpenRef.current && setMenuOpen(true);
        setInputValue(inputVal);
    }, [onInputChange]);
    const handleOnClearMouseDown = useCallback((e) => {
        handleMouseOrTouchEvent(e, e.type === 'mousedown');
        setSelectedOption(EMPTY_ARRAY);
        focusInput();
    }, []);
    const handleOnCaretMouseDown = useCallback((e) => {
        handleMouseOrTouchEvent(e, e.type === 'mousedown');
        focusInput();
        menuOpenRef.current ? setMenuOpen(false) : openMenuAndFocusOption(OptionIndexEnum.FIRST);
    }, [openMenuAndFocusOption]);
    return (React.createElement(ThemeProvider, { theme: theme },
        React.createElement(SelectWrapper, { id: selectId, role: 'combobox', "aria-haspopup": 'listbox', "aria-controls": inputId, "aria-expanded": menuOpen, onKeyDown: handleOnKeyDown, "data-testid": SELECT_CONTAINER_TESTID, className: addClassNames ? SELECT_CONTAINER_CLS : undefined },
            React.createElement(ControlWrapper, { ref: controlRef, isInvalid: isInvalid, isFocused: isFocused, isDisabled: isDisabled, onTouchEnd: handleOnControlMouseDown, onMouseDown: handleOnControlMouseDown, "data-testid": CONTROL_CONTAINER_TESTID, className: addClassNames ? CONTROL_CONTAINER_CLS : undefined },
                React.createElement(ValueWrapper, null,
                    React.createElement(Value, { isMulti: isMulti, inputValue: inputValue, placeholder: placeholder, selectedOption: selectedOption, focusedMultiValue: focusedMultiValue, renderOptionLabel: renderOptionLabelFn, renderMultiOptions: renderMultiOptions, removeSelectedOption: removeSelectedOption }),
                    React.createElement(AutosizeInput, { id: inputId, ref: inputRef, required: required, ariaLabel: ariaLabel, inputValue: inputValue, onBlur: handleOnInputBlur, onFocus: handleOnInputFocus, addClassNames: addClassNames, onChange: handleOnInputChange, ariaLabelledBy: ariaLabelledBy, selectedOption: selectedOption, readOnly: isDisabled || !isSearchable || !!focusedMultiValue })),
                React.createElement(IndicatorIcons, { menuOpen: menuOpen, clearIcon: clearIcon, caretIcon: caretIcon, isInvalid: isInvalid, isLoading: isLoading, isDisabled: isDisabled, loadingNode: loadingNode, addClassNames: addClassNames, onClearMouseDown: handleOnClearMouseDown, showClear: !!(isClearable && !isDisabled && isArrayWithLength(selectedOption)), onCaretMouseDown: (!isDisabled && !openMenuOnClick) ? handleOnCaretMouseDown : undefined })),
            React.createElement(MenuWrapper, { ref: menuRef, menuOpen: menuOpen, menuTop: menuStyleTop, onMouseDown: handleOnMenuMouseDown, "data-testid": MENU_CONTAINER_TESTID, className: addClassNames ? MENU_CONTAINER_CLS : undefined },
                React.createElement(Menu, { ref: listRef, isLoading: isLoading, height: menuHeightCalc, itemSize: menuItemSize, loadingMsg: loadingMsg, menuOptions: menuOptions, noOptionsMsg: noOptionsMsg, selectOption: selectOption, itemKeySelector: itemKeySelector, overscanCount: menuOverscanCount, width: menuWidth || theme.menu.width, renderOptionLabel: renderOptionLabelFn, focusedOptionIndex: focusedOption.index })),
            isAriaLiveEnabled && (React.createElement(AriaLiveRegion, { menuOpen: menuOpen, isFocused: isFocused, ariaLabel: ariaLabel, inputValue: inputValue, isSearchable: isSearchable, focusedOption: focusedOption, selectedOption: selectedOption, optionCount: menuOptions.length })))));
});
Select.displayName = 'Select';
export { Select };
